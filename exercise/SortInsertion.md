# 插入排序

## 思路  
将一个数据插入到一组有序数据中，并继续保持数据有序，即遍历有序数据，找到待插入数据位置并插入。那么，当有多个数据时，依次插入即可。  
以一个待排序的数组为例，初始有序的数据为第一个元素，处于 **已排序区间**，剩余元素处于 **未排序区间**，每次插入操作已排序区间长度加 1，未排序区间长度减 1，直至未排序区间长度为 0，排序完成。

## javascript 实现 
```js
/**
 * desc: 插入排序
 * input:
 * @param {Array} list
 */
function func(list) {
  if (list.length <= 1) return;

  // i 在未排序区间从前往后移动
  for (i = 1; i < list.length; i++) {
    const value = list[i];
    // j 在已排序区间从后往前移动
    let j = i - 1;
    for (; j >= 0; j--) {
      if (list[j] > value) {
        // 将 j 位置的数据后移一位
        list[j + 1] = list[j];
      } else {
        break;
      }
    }
    // 将数据插入（写在循环外，因为有可能 value 比已排序区间所有数据都小）
    list[j + 1] = value;
  }
}

/**
 * 测试
 */
const testList = [
  [0, 12, 15, 18, -2, 3, 7],
  [1, 2, 3, 4, 5, 6, 7],
  [7, 6, 5, 4, 3, 2, 1],
];
testList.forEach(list => {
  func(list);
  console.log('打印list: ', list);
});
```

### 时间复杂度
最好情况：数据完全有序，`n - 1` 插入操作，但每次插入直接插入数组末尾，最好情况时间复杂度为：$O(n)$。  
最坏情况：数据完全无序，分析方法与 **冒泡排序实现 2** 中相同，最坏情况时间复杂度为：$O(n^2)$。 
平均情况：在数组中插入一个数据平均时间复杂度是 $O(n)$，此算法总计 `n - 1` 次插入操作，因此平均情况时间复杂度为：$O(n^2)$.  

与冒泡排序相比的优势：在数据交换的过程，步骤较少。

### 空间复杂度
没有产生新数组，空间复杂度为：$O(1)$。

### 是否原地排序？
空间复杂度为 $O(1)$，是原地排序。

### 是否稳定排序？
相同的元素插入了右侧，是稳定排序。

